#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define vi vector<int> 
#define vs vector<string>  
#define vl vector<long long>  
#define nul nullptr  
// Single Linked List : 
class Node {
public:
	int date;
	Node* link = nul;
	Node(int num) : date(num), link(nullptr) {}
};
typedef Node* nodePtr;
class LinkedList {
private:
	nodePtr head;
public:
	LinkedList() : head(nul) {}
	void headInsert(int num) {
		nodePtr temp = new Node(num);
		temp->link = head;
		head = temp;
	}
	void print() {
		nodePtr temp = head;
		while (temp != nul) {
			cout << temp->date << " ";
			temp = temp->link;
		}
		cout << endl;
	}
	nodePtr search(int item) {
		nodePtr here = head;
		while (here != nul) {
			if (here->date == item)
				return here;
			here = here->link;
		}
		return nul;
	}
	void afterMe(nodePtr afterPtr, int num) {
		if (afterPtr == nul) return;
		nodePtr temp = new Node(num);
		temp->link = afterPtr->link;
		afterPtr->link = temp;
	}
	void remove(nodePtr afterPtr) {
		if (afterPtr == nul || afterPtr->link == nul) return;
		nodePtr temp = afterPtr->link;
		afterPtr->link = temp->link;
		delete temp;
	}
	void removeHead() {
		if (head == nul) return;
		nodePtr temp = head;
		head = head->link;
		delete temp;
	}
	~LinkedList() {
		while (head != nul) {
			removeHead();
		}
	}
};

// Double Linked List :  
class DNode {
public:
	int data;
	DNode* next = nul, * prv = nul;
};
typedef DNode* DNodePtr;
class DLinkedList {
private:
	DNodePtr head = nul;
	DNodePtr tail = nul;
	int size = 0;
public:
	void insertBeg(int num) {
		DNodePtr newnode = new DNode;
		newnode->data = num;
		newnode->prv = nul;
		newnode->next = head;
		if (head == nul)
			tail = newnode;
		else
			head->prv = newnode;
		head = newnode;
		++size;
	}
	void insertEnd(int num) {
		DNodePtr newnode = new DNode;
		newnode->data = num;
		newnode->prv = tail;
		tail->next = newnode;
		tail = newnode;
		++size;
	}
	void insertPtr(DNodePtr ptr, int num) {
		if (ptr == head) {
			insertBeg(num);
			return;
		}
		if (ptr == tail) {
			insertEnd(num);
			return;
		}
		DNodePtr newnode = new DNode;
		newnode->data = num;
		newnode->next = ptr->next;
		newnode->prv = ptr;
		ptr->next = newnode;
		newnode->next->prv = newnode;
		++size;
	}
	void insertindex(int idx, int num) {
		if (idx < 0 || idx > size) {
			cout << "This index is wrong!!!" << endl;
			return;
		}
		if (idx == 0) {
			insertBeg(num);
			return;
		}
		if (idx == size) {
			insertEnd(num);
			return;
		}
		DNodePtr temp = head;
		for (int i = 0; i < idx - 1; ++i) {
			temp = temp->next;
		}
		insertPtr(temp, num);
	}
	void detStr() {
		if (head == nul) {
			cout << "The List is Empty!!!" << endl;
			return;
		}
		DNodePtr temp = head;
		head = head->next;
		head->prv = nul;
		if (head == nul)
			tail = nul;
		temp = nul;
		--size;
	}
	void detEnd() {
		if (head == nul) {
			cout << "The List is Empty!!!" << endl;
			return;
		}
		DNodePtr temp = tail;
		tail = tail->prv;
		tail->next = nul;
		if (tail == nul)
			head = nul;
		temp = nul;
		--size;
	}
	void detPtr(DNodePtr ptr) {
		if (head == nul) {
			cout << "This List is Empty!!!!!" << endl;
			return;
		}
		if (ptr == head) {
			detStr();
			return;
		}
		if (ptr == tail) {
			detEnd();
			return;
		}
		ptr->next->prv = ptr->prv;
		ptr->prv->next = ptr->next;
		ptr = nul;
	}
	void detIndex(int idx) {
		if (idx < 0 || idx >= size) {
			cout << "This index is wrong!!!" << endl;
			return;
		}
		if (idx == 0) {
			detStr();
			return;
		}
		if (idx == size - 1) {
			detEnd();
			return;
		}
		DNodePtr temp = head;
		for (int i = 0; i < idx; ++i) {
			temp = temp->next;
		}
		detPtr(temp);
	}
	DNodePtr ser(int num) {
		DNodePtr temp = head;
		while (temp != nul) {
			if (temp->data == num)
				return temp;
			temp = temp->next;
		}
		return nul;
	}
	DNodePtr ptrOfIndex(int idx) {
		if (idx < 0 || idx >= size) {
			cout << "This index is wrong!!!" << endl;
			return nul;
		}
		DNodePtr temp = head;
		for (int i = 0; i < idx; ++i) {
			temp = temp->next;
		}
		return temp;
	}
	void swap(DNodePtr num1, DNodePtr num2) {
		if (num1 == nul || num2 == nul || num1 == num2)
			return;
		if (num1->next == num2) {
			if (num1->prv != nul)
				num1->prv->next = num2;
			if (num2->next != nul)
				num2->next->prv = num1;
			num1->next = num2->next;
			num2->prv = num1->prv;

			num2->next = num1;
			num1->prv = num2;
		}
		else if (num2->next == num1) {
			swap(num2, num1);
			return;
		}
		else {
			DNodePtr p1 = num1->prv, n1 = num1->next;
			DNodePtr p2 = num2->prv, n2 = num2->next;
			if (p1 != nul) p1->next = num2;
			if (n1 != nul) n1->prv = num2;
			if (p2 != nul) p2->next = num1;
			if (n2 != nul) n2->prv = num1;
			num1->prv = p2;
			num1->next = n2;
			num2->prv = p1;
			num2->next = n1;
		}
		if (num1 == head)
			head = num2;
		else if (num2 == head)
			head = num1;

		if (num1 == tail)
			tail = num2;
		else if (num2 == tail)
			tail = num1;
	}
	void sort() {
		if (head == nul || head->next == nul)
			return;
		bool swapped;
		do {
			swapped = false;
			DNodePtr curr = head;
			while (curr->next != nul) {
				if (curr->data > curr->next->data) {
					swap(curr, curr->next);
					swapped = true;
					if (curr->prv != nul)
						curr = curr->prv;
				}
				curr = curr->next;
			}
		} while (swapped);
	}
	void reverse() {
		DNodePtr current = head;
		DNodePtr temp = nul;
		while (current != nul) {
			temp = current->prv;
			current->prv = current->next;
			current->next = temp;
			current = current->prv;
		}
		if (temp != nul) {
			head = temp->prv;
		}
	}
	bool isEmpty() {
		return size == 0;
	}
	int getSzie() {
		return size;
	}
	void clear() {
		while (!isEmpty()) {
			detStr();
		}
	}
	void print() {
		DNodePtr temp = head;
		while (temp != nul) {
			cout << temp->data << " ";
			temp = temp->next;
		}
		cout << endl;
	}
	~DLinkedList() {
		while (head != nul) {
			DNodePtr temp = head;
			head = head->next;
			temp = nul;
		}
	}
};

// Two Dimensional Linked List:
class TNode { 
public:
	int data; 
	TNode* next = nul, * prv = nul, * up = nul, * down = nul; 
};
typedef TNode* TNodePtr;
class RowProxy { // for [][]
	TNodePtr row;
public:
	RowProxy(TNodePtr r) {
		row = r;
	}
	int& operator[](int y) {
		TNodePtr col = row;
		for (int i = 0; i < y && col != nul; ++i)
			col = col->next;
		if (col == nul)
			cout << "Column index is wrong!!!" << endl;
		return col->data;
	}
};
class List2Dim {
private:
	TNodePtr head = nul;
	int sizerow = 0;
public:
	int getSizeRows() {
		return sizerow;
	}
	bool isEmpty() {
		return head == nul;
	}
	void addRowEnd(int num) {
		TNodePtr newnode = new TNode;
		newnode->data = num;
		if (head == nul) {
			head = newnode;
			sizerow = 1;
			return;
		}
		TNodePtr temp = head;
		while (temp->down != nul)
			temp = temp->down;
		temp->down = newnode;
		newnode->up = temp;
		++sizerow;
	}
	void addRowBeg(int num) {
		TNodePtr newnode = new TNode;
		newnode->data = num;
		if (head == nul) {
			head = newnode;
			sizerow = 1;
			return;
		}
		newnode->down = head;
		head->up = newnode;
		head = newnode;
		++sizerow;
	}
	void addByIndex(int x, int y, int num) {
		if (x < 0 || x >= sizerow) {
			cout << "Invalid row index!" << endl;
			return;
		}
		TNodePtr row = head;
		for (int i = 0; i < x; ++i) {
			row = row->down;
		}
		TNodePtr newnode = new TNode;
		newnode->data = num;
		if (y == 0) { // insert in main row
			newnode->next = row;
			if (row != nul)
				row->prv = newnode;
			if (row->up) {
				newnode->up = row->up;
				row->up->down = newnode;
			}
			if (row->down) {
				newnode->down = row->down;
				row->down->up = newnode;
			}
			if (x == 0)
				head = newnode;
			else {
				TNodePtr upper = head;
				for (int i = 0; i < x - 1; ++i)
					upper = upper->down;
				upper->down = newnode;
			}
		}
		else {
			TNodePtr prev = row;
			for (int i = 0; i < y - 1 && prev->next; ++i)
				prev = prev->next;
			newnode->next = prev->next;
			if (prev->next != nul)
				prev->next->prv = newnode;
			prev->next = newnode;
			newnode->prv = prev;
			TNodePtr upRow = row->up;
			for (int i = 0; i < y && upRow; ++i)
				upRow = upRow->next;
			if (upRow) {
				newnode->up = upRow;
				upRow->down = newnode;
			}
			TNodePtr downRow = row->down;
			for (int i = 0; i < y && downRow; ++i)
				downRow = downRow->next;
			if (downRow) {
				newnode->down = downRow;
				downRow->up = newnode;
			}
		}
	}
	void removeRow(int x) {
		if (x < 0 || x >= sizerow || head == nul) {
			cout << "Invalid row index!" << endl;
			return;
		}
		TNodePtr tar = head;
		for (int i = 0; i < x; ++i)
			tar = tar->down;
		if (tar->up)
			tar->up->down = tar->down;
		else
			head = tar->down;
		if (tar->down)
			tar->down->up = tar->up;
		TNodePtr curr = tar;
		while (curr != nul) {
			TNodePtr nxt = curr->next;
			delete curr;
			curr = nxt;
		}
		--sizerow;
	}
	void removeColm(int x) {
		if (head == nul) {  
			cout << "List is empty!" << endl;
			return;
		}
		if (x == 0) {
			head = head->next;
			TNodePtr rows = head; 
			while (rows != nul) {
				rows->prv = nul;
				rows = rows->down;
			}
			return;
		}
		TNodePtr rows = head;
		while (rows != nul) {
			TNodePtr col = rows, prev = nul; 
			for (int i = 0; i < x && col != nul; ++i) { 
				prev = col; 
				col = col->next;
			} 
			if (col != nul) {
				if (rows == head && x == 0) {
					head = head->next; 
					if (head != nul) { 
						head->prv = nul; 
					}
				}
				else {
					if (prev != nul) {  
						prev->next = col->next; 
					}
					if (col->next != nul) {   
						col->next->prv = prev;  
					}
				}
				if (col->up != nul)
					col->up->down = col->down;
				if (col->down != nul  )
					col->down ->up = col ->up;
				delete col;
			}
			rows = rows->down; 
		} 
	}
	int getDataIndex(int x, int y) {
		if (x < 0 || x >= sizerow || head == nul) {
			cout << "this Index is Wrong!!!" << endl;
			return -1;
		}
		TNodePtr row = head;
		for (int i = 0; i < x && row != nul; ++i)
			row = row->down;
		if (row == nul) {
			cout << "Row not found!" << endl;
			return -1;
		}
		TNodePtr col = row;
		for (int i = 0; i < y && col != nul; ++i)
			col = col->next;
		if (col == nul) {
			cout << "Column not found!" << endl;
			return -1;
		}
		return col->data;
	}
	RowProxy operator[](int x) {
		if (x < 0 || x >= sizerow || head == nul) { 
			cout << "Row index is wrong!!!" << endl;
		}
		TNodePtr row = head;
		for (int i = 0; i < x && row != nul; ++i) 
			row = row->down;
		return RowProxy(row);
	}
	pair<int, int> operator()(int num) { // for search and return the index
		TNodePtr row = head;
		int idxrow = 0;
		while (row != nul) {
			TNodePtr col = row;
			int idxcol = 0;
			while (col != nul) {
				if (col->data == num)
					return { idxrow,idxcol };
				col = col->next;
				++idxcol;
			}
			row = row->down;
			++idxrow; 
		}
		return { -1,-1 };
	}
	int countRowEle(int x) {
		if (x < 0 || x >= sizerow || head == nul) {
			cout << "This Index is wrong!!!" << endl;
			return -1;
		}
		TNodePtr row = head;
		for (int i = 0; i < x && row != nul; ++i)
			row = row->down;
		int countcol = 0;
		while (row != nul) {
			++countcol;
			row = row->next;
		}
		return countcol; 
	}
	void clearList() {
		TNodePtr rows = head;
		while (rows != nul) {
			TNodePtr cols = rows;
			rows = rows->down;
			while (cols != nul) {
				TNodePtr temp = cols;
				cols = cols->next;
				delete temp;
			}
		}
		head = nul;
		sizerow = 0;
	}
	void mapFunction(int (*func)(int)) {
		TNodePtr rows = head; 
		while (rows != nul) { 
			TNodePtr cols = rows; 
			while (cols != nul) {
				cols->data = func(cols->data); 
				cols = cols->next; 
			}
			rows = rows->down;
		}
	}
	void printAllList() {
		if (head == nul) {
			cout << "The List is Empty!!!" << endl;
			return;
		}
		cout << "Print The List : " << endl;
		TNodePtr rows = head;
		int idx = 0;
		while (rows != nul) {
			cout << "Row " << idx++ << " : ";
			TNodePtr cols = rows;
			while (cols != nul) {
				cout << cols->data << " ";
				cols = cols->next;
			}
			cout << endl;
			rows = rows->down;
		}
		cout << endl;
	}
	void addRowArray(int* arr, int size) { 
		if (arr == nul || size <= 0) {  
			cout << "Invalid array or size!" << endl;
			return;
		}
		addRowEnd(arr[0]);
		int idx = sizerow - 1; 
		for (int i = 1; i < size; ++i) { 
			addByIndex(idx, i, arr[i]); 
		}
	} 
	void addColmArray(int* arr, int size) {
		if (arr == nul || size <= 0) { 
			cout << "Invalid array or size!" << endl; 
			return;
		}
		for (int i = 0; i < size; ++i) { 
			addByIndex(i, countRowEle(i), arr[i]);
		}
	}
	List2Dim operator+(const List2Dim& other) {// marge two list 2D
		List2Dim res;
		TNodePtr row1 = head;
		while (row1 != nul) {
			TNodePtr col1 = row1;
			int idxRow = res.getSizeRows();
			res.addRowEnd(col1->data);
			col1 = col1->next;
			while (col1 != nul) {
				res.addByIndex(idxRow, res.countRowEle(idxRow), col1->data);
				col1 = col1->next;
			}
			row1 = row1->down;
		}
		TNodePtr row2 = other.head; 
		while (row2 != nul) {
			TNodePtr col2 = row2;
			int idxRow2 = res.getSizeRows(); 
			res.addRowEnd(col2->data); 
			col2 = col2->next;
			while (col2 != nul) {
				res.addByIndex(idxRow2, res.countRowEle(idxRow2), col2->data); 
				col2 = col2->next; 
			}
			row2 = row2->down; 
		}
		return res;
	}  
	bool operator==(const List2Dim& other) const {
		if (sizerow != other.sizerow) return false;
		TNodePtr row1 = head, row2 = other.head; 
		while (row1 != nul && row2 != nul) {
			TNodePtr col1 = row1, col2 = row2;
			while (col1 != nul && col2 != nul) {
				if (col1->data != col2->data) return false;
				col1 = col1->next; col2 = col2->next;
				if (col1 != nul || col2 != nul) return false; 
			}
			row1 = row1->down; row2 = row2->down;
		}
		return row1 == nul && row2 == nul; 
	}
	void reverseRows() {
		if (head == nul || sizerow <= 1) return; 
		TNodePtr cur = head, nxt = nul, prv = nul;
		while (cur != nul) {
			nxt = cur->down;
			cur->down = prv;
			cur->up = nxt;
			prv = cur;
			cur = nxt;
		}
		head = prv;
	}
	List2Dim& operator=(const List2Dim& other) { 
		if (this != &other) { 
			clearList(); 
			TNodePtr rows = other.head; 
			while (rows != nul) { 
				TNodePtr cols = rows; 
				int rowIdx = sizerow; 
				addRowEnd(cols->data); 
				cols = cols->next; 
				while (cols != nul) { 
					addByIndex(rowIdx, countRowEle(rowIdx), cols->data); 
					cols = cols->next; 
				}
				rows = rows->down; 
			}
		}
		return *this;
	}
	void add2DArray(int arr[3][3], int x, int y) {
		if (arr == nul || x <= 0 || y <= 0) {
			cout << "Invalid array or size!" << endl;
			return;
		}
		for (int i = 0; i < x; ++i) {
			addRowArray(arr[i], y);
		}
	}
	~List2Dim() { 
		clearList(); 
	} 
};
int doubleValue(int x) { return x * 2; } // for test my mapFunction
int main() {
	ios::sync_with_stdio(false); 
	cin.tie(nullptr); 

	/*// Use single Linked List  :
	cout << "My Tests in single Linked List  : " << endl;
	LinkedList list;
	list.headInsert(5);list.headInsert(10);list.headInsert(20);
	list.print();
	nodePtr found = list.search(10);
	if (found != nul) list.afterMe(found, 15);
	list.print();
	list.remove(found); list.print();
	// Use Double Linked List :
	cout << "My Tests in Double Linked List  : " << endl;
	DLinkedList dls1;
	dls1.insertBeg(1); dls1.insertBeg(2); dls1.insertBeg(3);
	dls1.print();
	dls1.insertEnd(5); dls1.insertEnd(6);
	dls1.print();
	DNodePtr ptr = dls1.ser(2);
	cout << "The Pointer of " << 2 << " : " << ptr << endl;
	dls1.insertPtr(ptr, 10);
	dls1.print();
	dls1.insertindex(3, 20);
	dls1.print();
	dls1.detEnd(); dls1.print();
	dls1.detStr(); dls1.print();
	dls1.detPtr(dls1.ser(20)); dls1.print();
	dls1.detIndex(2); dls1.print();
	dls1.insertBeg(22); dls1.insertBeg(33); dls1.print();
	dls1.insertEnd(12); dls1.insertEnd(13); dls1.print();
	dls1.reverse(); dls1.print();
	dls1.sort(); dls1.print();  */
	// Use Two Dimensional Linked List :
	List2Dim ls2d;
	ls2d.addRowEnd(1); ls2d.addRowEnd(2); ls2d.addRowEnd(3);
	ls2d.printAllList();
	ls2d.addByIndex(0, 1, 10); ls2d.addByIndex(1, 1, 100); ls2d.addByIndex(2, 1, 1000); ls2d.addByIndex(1, 2, 200); ls2d.addByIndex(0, 0, 22);
	ls2d.printAllList();
	ls2d.removeRow(1); ls2d.printAllList();
	ls2d.addRowBeg(12); ls2d.addByIndex(0, 1, 100); ls2d.printAllList();
	cout << ls2d.getDataIndex(1, 1) << endl;
	cout << ls2d[1][1] << endl;  
	cout << "Index of Number 100 in 2D linked list : [" << ls2d(100).first << "][" << ls2d(100).second << "]" << endl;
	cout << ls2d.countRowEle(1) << endl;
	ls2d.mapFunction(doubleValue); ls2d.printAllList();
	int arr[] = { 11,12,13,14,15 };
	ls2d.addRowArray(arr, 5); ls2d.printAllList();
	int arr2[] = { 21,22,23 };
	ls2d.addColmArray(arr2, 3); ls2d.printAllList();
	List2Dim d2; 
	d2.addRowArray(arr, 5); d2.addRowArray(arr, 5); d2.printAllList();
	List2Dim res = ls2d + d2;
	res.printAllList();
	if (d2 == ls2d) 
		cout << "Are Equal!!" << endl;
	else
		cout << "Are not Equal!!!" << endl;
	ls2d.reverseRows(); ls2d.printAllList();
	ls2d.removeColm(1);ls2d.printAllList(); 
	int arr2d[3][3] = { {1,2,3},{4,5,6},{7,8,9} };
	ls2d.add2DArray(arr2d, 3, 3); ls2d.printAllList();
	return 0; 
}